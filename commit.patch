diff --git a/Makefile b/Makefile
index b971308..1f68a81 100644
--- a/Makefile
+++ b/Makefile
@@ -157,6 +157,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_find\
 
 
 ifeq ($(LAB),syscall)
@@ -242,15 +245,8 @@ qemu-gdb: $K/kernel .gdbinit fs.img
 	@echo "*** Now run 'gdb' in another window." 1>&2
 	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
 
-GDBARGS = 
-GDBARGS += -ex 'set architecture riscv:rv64'
-GDBARGS += -ex 'target remote 127.0.0.1:$(GDBPORT)'
-GDBARGS += -ex 'symbol-file kernel/kernel'
-GDBARGS += -ex 'set riscv use-compressed-breakpoints yes'
-
-
 gdb: 
-	$(GDB) $(GDBARGS)
+	$(GDB)
 
 ##
 ##  FOR testing lab grading script
diff --git a/commands.gdb b/commands.gdb
new file mode 100644
index 0000000..dfb1e52
--- /dev/null
+++ b/commands.gdb
@@ -0,0 +1,6 @@
+b trap.c:81
+c
+p cpus[$tp]->proc->name
+c
+p cpus[$tp]->proc->name
+da
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..744e4ab
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,80 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+// 声明 fmtname 函数
+char *fmtname(char *path);
+
+void find(char *path, char *name) {
+    char buf[512], *p;
+    int fd;
+    struct dirent de;
+    struct stat st;
+
+    if ((fd = open(path, 0)) < 0) {
+        fprintf(2, "find: cannot open %s\n", path);
+        return;
+    }
+
+    if (fstat(fd, &st) < 0) {
+        fprintf(2, "find: cannot stat %s\n", path);
+        close(fd);
+        return;
+    }
+
+    switch (st.type) {
+        case T_DIR:
+            if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
+                printf("find: path too long\n");
+                break;
+            }
+            strcpy(buf, path);
+            p = buf + strlen(buf);
+            *p++ = '/';
+            while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+                if (de.inum == 0) continue; // 跳过空项
+                memmove(p, de.name, DIRSIZ);
+                p[DIRSIZ] = 0;
+
+                // 忽略 . 和 ..
+                if (strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
+                    continue;
+
+                // 递归查找子目录
+                find(buf, name);
+
+                // 检查当前文件名，无论是文件还是目录，都可以输出且只在这个case输出
+                if (strcmp(fmtname(buf), name) == 0) {
+                    printf("%s\n", buf); // 打印匹配的文件或目录路径
+                }
+            }
+            break;
+    }
+    close(fd);
+}
+
+char *fmtname(char *path) {
+    static char buf[DIRSIZ + 1];
+    char *p;
+
+    // 从路径中提取文件名
+    for (p = path + strlen(path); p >= path && *p != '/'; p--)
+        ;
+    p++; // 跳过 '/'
+
+    // 处理文件名长度
+    if (strlen(p) >= DIRSIZ) return p;
+    memmove(buf, p, strlen(p));
+    buf[strlen(p)] = '\0';
+    return buf; // 返回格式化后的文件名
+}
+
+int main(int argc, char *argv[]) {
+    if (argc != 3) {
+        fprintf(2, "Usage: find <path> <name>\n");
+        exit(1);
+    }
+    find(argv[1], argv[2]);
+    exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..b9b9913
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,44 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main() {
+    int f2c[2];         // 定义一个管道,f2c用于父进程向子进程传输数据
+    
+    // 创建管道,并检查是否成功
+    if (pipe(f2c) < 0) {
+        printf("pipe error\n");
+        exit(-1);
+    }
+
+    int pid = fork();   // 创建子进程
+    if (pid < 0) {
+        printf("fork error\n");
+        exit(-1);
+    }
+
+    if (pid > 0) { // 父进程写f2c管道
+        close(f2c[0]);  // 关闭f2c读端
+
+        // 向子进程传递父进程的pid
+        int parent_pid = getpid(); // 获取父进程PID
+        write(f2c[1], (char*)&parent_pid, sizeof(parent_pid));      // 将父进程的pid写入管道
+        
+        close(f2c[1]);  // 关闭f2c写端
+
+        wait(0); // 等待子进程结束后再打印避免父子进程的printf语句交替进行
+        printf("%d: received pong from pid %d\n", parent_pid, pid); // 这里的pid由fork函数返回值提供
+
+    } else {    // 子进程读f2c管道
+        close(f2c[1]);  // 关闭f2c写端
+        
+        // 从管道中读取父进程的pid
+        int received_parent_pid;
+        read(f2c[0], (char*)&received_parent_pid, sizeof(received_parent_pid)); // 从管道中读取父进程的pid
+        printf("%d: received ping from pid %d\n", getpid(), received_parent_pid);        
+
+        close(f2c[0]);  // 关闭f2c读端
+
+        exit(0);    // 子进程退出
+    }
+    return 0;
+}
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..9c16989
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc, char* argv[]) {
+    if(argc != 2) {
+        printf("Sleep needs one argument!\n");  //检查参数数量是否正确
+        exit(-1);
+    }
+    int ticks = atoi(argv[1]);  //将字符串参数转为整数
+    sleep(ticks);               // 使用系统调用sleep
+    printf("(nothing happens for a little while)\n");
+    exit(0);    //确保进程退出
+}
\ No newline at end of file
